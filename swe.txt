L1

-efficacia: garantire la qualità dei prodotti, determinata dal grado di conformità del prodotto rispetto alle norme vigenti e agli obiettivi prefissati.

-efficienza: contenere i costi e i tempi di produzione, inversamente proporzionale alla quantità di risorse impiegate nell’esecuzione delle attività richieste.

-massimizzare efficacia ed efficienza: Riuscire a soddisfare obiettivi prefissati entro limiti certi di tempo e di sforzo.

manutenibilità: è una qualità del software; 
->può essere correttiva per correggere difetti eventualmente rilevati; 
->adattiva per adattare il sistema alla variazione dei requisiti; 
->evolutiva per aggiungere funzionalità al sistema.

-best practice: Prassi (modo di fare) che per esperienza e per studio abbia mostrato di garantire i migliori risultati in circostanze note e specifiche.

-stake holder: portatori d'interesse, L’insieme di persone a vario titolo coinvolte nel ciclo di vita del SW, che hanno influenza sul prodotto o sul processo.

-swe: L’approccio sistematico, disciplinato e quantificabile allo sviluppo, l’uso, la manutenzione e il ritiro del SW(glossario ieee).
L’applicazione di principi ingegneristici al SW, Il controllo di efficienza ed efficacia ha bisogno di un approccio sistematico.
Approccio Sistematico = metodico, rispettare un metodo noto, una check-list, secondo un certo ordine. Seguendo norme di condotta, aderendo a standard.
Approccio Disciplinato = insieme di norme che seguo, o meglio ancora delle best practice.
Approccio Quantificabile = so quanto consumerò, con una stima ragionevole.
Approccio ingegneristico: Disciplinato, sistematico, quantificabile.

-Pianificazione: Organizzare e controllare tempo, risorse e risultati.
-Analisi dei requisiti: Definire cosa bisogna fare.
-Progettazione: Definire come bisogna farlo.
-Realizzazione: Farlo con la massima efficienza e la massima efficacia.
-Verifica e validazione: Assicurare che quanto fatto soddisfi i requisiti e non contenga errori.
-Manutenzione: Assicurare pieno utilizzabilità del SW fino al momento del suo ritiro.

L2(+L1)
-ciclo di vita del sw: Gli stati che il prodotto assume dal concepimento al ritiro.
Per organizzare al meglio le attività necessarie all’interno di vincoli dati di tempo, di risorse e di obiettivi.
Stati sono Concezione → sviluppo → utilizzo → ritiro.

-Processi di ciclo di vita: Specificano le attività che vanno svolte per causare transizioni di stato nel ciclo di vita di un prodotto SW.

-Modelli di ciclo di vita: Descrivono come i processi si relazionano tra loro nel tempo rispetto agli stati di ciclo di vita.
Base concettuale intorno alla quale pianificare, organizzare, eseguire e controllare lo svolgimento delle attività necessarie.
Vederlo come una macchina a stati, stati rappresentano il grado di maturazione del prodotto SW, archi (transizioni di stato) sono l’insieme di attività svolte sul prodotto che servono a farlo avanzare nel grado di maturazione.

(da L3)
Il modello di ciclo di vita adottato pone vincoli su pianificazione e gestione del progetto, indipendente da metodi e strumenti. 
Descrivono come i processi si evolvono nel tempo rispetto agli stati nel ciclo di vita.
L’adozione di un modello richiede un sistema di qualità per garantire e misurare conformità e maturità.
[La durata temporale entro uno stato di ciclo di vita o in una transizione tra essi viene detta «fase»]

-code and fix, raggiungere la correttezza “by correction”.
-sequenziale a cascata: fasi definite per attività previste e prodotti attesi in ingresso e in uscita, contenuto e struttura dei documenti, scadenze. Fasi distinte fra loro. Il modello originale prevede che non si possa mai essere in due stati diversi allo stesso tempo e che non si possa tornare ad uno stato. Non ammete variazione requisiti. Passaggio di fase basato su documentazione. Il passaggio da una fase alla successiva è basato sulla documentazione, ogni fase produce documenti che la concretizzano e devono essere approvati per il passaggio alla fase successiva. Corretto in cascata con ritorni.

---incrementali: producono valore ad ogni incremento, funzionalità essenziali sono sviluppate nei primi incrementi. Incremento è quantificabile.
Incremento = Procedere per incrementi significa aggiungere a un impianto base.
---iterativi adattamento. iterazione non qunatificabile. 
Iterazione = Procedere per iterazioni significa operare raffinamenti o rivisitazioni.

-incrementale:  approssimare la soluzione per incrementi, requisiti utente sono classificati e trattati in base alla loro importanza strategica.
[ogni incremento attraversa tutte le fasi del modello sequenziale]

-evolutivo: rispondere a bisogni non inizialmente preventivabili, può richiedere il rilascio e il mantenimento di più versioni del prodotto
simultaneamente disponibili usabili dall'utente, può richiedere rilascio più versioni. Riattraversamento più fasi di ciclo di vita. 

-a spirale: Cicli interni rapidi e ripetuti, dedicati ad analisi e sviluppi prototipali(ANALISI DEI RISCHI). Cicli esterni che aderiscono a un qualsiasi altro modello standard di ciclo di vita. Ad ogni ciclo si analizzano i rischi e si compiono simulazioni. 
Attività principali per ogni ciclo: Definizione degli obiettivi, Analisi dei rischi, Sviluppo e validazione, Pianificazione(prossimo ciclo).

-a componenti: molto di quello che ci serve fare è già stato fatto e molto di quello che faremo ci potrà servire ancora. Riuso sistematico di componenti preesistenti proprie oppure “off-the-shelf”.

-agili: Backlog, sprint, daily scrum, incrementi devono essere funzionanti, pezzi realizzabili.
1) Individuals and interactions over processes and tools L’eccessiva rigidità ostacola l’emergere del valore
2) Working sofware over comprehensive documentation La documentazione non sempre corrisponde a SW funzionante
3) Customer collaboration over contract negotiation L’interazione con gli stakeholder va incentivata e non ingessata
4) Responding to change over following a plan La capacità di adattamento al cambiare delle situazioni è importante.

-controllo di versione: ciò che è oggetto di manutenzione ha una storia(il controllo di versione) che va gestita con controllo di versione.

-configurazione: Se un insieme è composto di parti, quali esse sono e il modo in cui esse devono stare insieme è detto “configurazione”,
ogni sistema fatto di parti va gestito con controllo di configurazione. Ogni configuration item ha una sua versione(storia).

-Prototipo: 
Serve per provare e scegliere soluzioni Può essere “usa e getta” (nel caso delle iterazioni) oppure fornire stati di incremento (baseline). Necessità di fornire / utilità di cercare evidenza preliminare di fattibilità. Baseline è stato di incremento, punto di arrivo tecnico dal quale non scendo, risultato sulla quale baso l'incremento.[baseline più avanti]

-Riuso: 
Occasionale (opportunistico) – «copia-incolla» a basso costo e scarso impatto, 
Sistematico (per progetto, per prodotto, per azienda) a maggior costo ma maggior impatto.
(da L7)

Riuso: 
Capitalizzare sottosistemi già esistenti
->Impiegandoli più volte per più prodotti
->Ottenendo minor costo realizzativo
->Ottenendo minor costo di verifica

Problemi del riuso
->Progettare per riuso è più difficile (Bisogna anticipare bisogni futuri) 
->Progettare con riuso non è immediato (Bisogna minimizzare le modifiche alle componenti riusati per non perderne il valore)

Riuso è Puro costo nel breve periodo
->Diventa risparmio nel medio termine (quindi è un investimento) 



-processo: Un processo è un insieme di attività correlate e coese che trasformano ingressi in uscite secondo regole fissate, consumando risorse nel farlo (Glossario ISO 9000).

-Lo standard come modello di azione: Definizione e imposizione di procedure, Definizione e proposizione di processi da specializzare
-Lo standard come modello di valutazione Identificazione di “best practice” CMMI, SPICE, ISO/IEC TR 15504.

Standard di processo: è un cuneo che non mi fa scendere, non peggioro.


-modello ad alto livello: identifica processi sviluppo sw, responsabilità sui processi, identifica prodotti dei processi.

ISO/IEC 12207 è il modello più noto e riferito per lo standard (generale) di processo, modello ad alto livello, identifica i processi dello sviluppo software, descrive i processi in termini di attività e compiti elementari, i prodotti dei processi, specifica le responsabilità sui processi.

-processi primari: se ci sono allora esiste il progetto; acquisizione= gestione fornitori; fornitura= gestione rapporto con clienti; sviluppo;
gestione operativa= utilizzo, installazione erogazione prodotti/servizi; manutenzione= correzione adattamento evoluzione.

-processi di supporto: procedure da chiamare quando  ne si ha il bisogno; documentazione, accertamento qualità, gestione versioni e configurazione, qualità=verifica+validazione, revisioni congiunte con il cliente, verifiche ispettive interne, risoluzione dei problemi.

-processi organizzativi: per il lavoro collaborativo e l'ambiente, defiiscono la struttura organizzativa a precindere dal prodotto; gestione processi, gestione infrastrutture, miglioramento del processo, formazione del personale.

Fine L2

-modularità: I processi sono tra loro relazionati in modo chiaro e distinto.
-coesione: Le attività di processo sono ben definite e correlate tra di loro (e così anche i compiti al loro interno).

-Processo standard: Riferimento di base generico, condiviso tra aziende diverse nello stesso dominio applicativo.
-Processo definito: Specializzazione di processo standard, per adattarlo alle specifiche esigenze e caratteristiche aziendali.
-Processo di progetto: Istanziazione di processi definiti, utilizzano risorse aziendali per raggiungere obiettivi prefissati e limitati nel tempo, cioè progetti.

-PDCA: Organizzazione interna dei processi incentrata sul principio del miglioramento continuo (W.A. Shewhard, W.E. Deming)
Pianificare (Plan): definire attività, scadenze, responsabilità, risorse utili a raggiungere specifici obiettivi di miglioramento, gestione risorse!
Eseguire (Do): eseguire le attività secondo P, realizzazione prodotto!
Valutare (Check): verificare l’esito delle azioni di miglioramento rispetto alle attese, misurazione e analisi. Si studiano i risultati della fase precedente (do) e li si cofrontano con gli obiettivi individuati nella prima fase (plan).
Agire (Act): applicare correzioni alle carenze rilevate e standardizzare quanto è andato bene.

L4

-log è l'evento che lascia la traccia
-push/pull alternative di richiesta infomrazione
Effettuare misurazioni allo scopo di massimizzare l'efficineza ricevendo infomrazioni in modo push.

-ruolo = funzione aziendale assegnata a progetto.
-profilo professionale = competenze tecnologiche, esperienza, requisiti per assunzione di un ruolo in un progetto.

Ruoli
-responsabile: rappresenta il progetto, responsabilità di pianificazione, risorse umane, gestione costi. Redazione e manutenzione di regole e
procedure di lavoro.
-amministratore: amministra risorse e infrastrutture, gestione documentazione, controllo versione+configurazione, risoluzione problemi legati alla gestione processi. Predispone strumenti e regole.
-analista: analisi requisiti, capisce il problmea non sviluppa la soluzione.
-progettista: sviluppa la soluzione.
-programmatore: puro esecutore.
-verificatore: verifica ciò ch eè stato fatto dagli altri, che sia corretto e soddisfi le attese.

-Work Breakdown Structure: scomporre attività in sottoattività. Attribuibili ad individui.
-Gantt: rappresentare durata, confronto stime e progressi, sequanzialità e parallelismo (non adatto per dipendenze).
-PERT: dipendenze temporali tra attività, slack. Un tale diagramma è un grafo orientato dove gli archi rappresentano le attività, mentre i nodi sono degli eventi. Ogni evento ha una data minima a partire da cui può accadere e una data massima oltre la quale esso ritarda gli eventi successivi; la differenza tra questi due tempi è detta slack time.

COCOMO constructive cost model m/p=CxMxD^s
funzione matematica che produce in uscita un valore in tempo/persona.
fattori statici che compaiono identificano:
C complessità del progetto. Valore soggettivo che decresce con l’esperienza (valore basso, modesta complessità; valore alto, alta complessità).
D dimensione stimata del prodotto (diversa dalla complessità) anch’essa dipendente dall’esperienza misurato in KDSI (Kilo Delivered Source Instruction), è l'unità di misura della dimensione stimata del prodotto software D, in cui si esprime la dimensione del prodotto che rappresenta il peso del codice sorgente consegnato richiesto per il progetto.
M moltiplicatori di costo, dice che altri elementi del progetto (anche esterni) incidono nella dimensione del progetto (ad esempio una collaborazione remota tra gli sviluppatori..)
S fattore di complessità (del codice)
Bassa complessità: tutti gli sviluppatori coinvolti sul progetto hanno una buona visione dei contenuti del progetto
Media complessità: per capire tutto bisogna tornare al “divide et impera”, capendo le parti singole ma nel complesso un po’ meno
Elevata complessità (embedded): il prodotto interagisce con componenti esterne che non sono parte del progetto sulle quali noi abbiamo zero influenza
[...]

-Identificazione dei rischi: In relazione al progetto, al prodotto, al business.
-Analisi dei rischi: Valutazione della probabilità di occorrenza, Valutazione delle conseguenze.
-Verifica del livello di rischio da effettuare su base regolare per determinare il livello corrente di rischio.
Fonti di rischio:
◦ tecnologie
◦ rapporti interpersonali
◦ organizzazione del lavoro
◦ requisiti e rapporti con gli stakeholder
◦ tempi e costi

L5

Massima efficacia nel prodotto con massima efficienza nel lavoro.

I documenti sono utili se e solo se sono sempre disponibili, chiaramente identificati, corretti nei contenuti, verificati e approvati, aggiornati, datati e dotati di versione.
La loro diffusione deve essere controllata, I destinatari devono essere chiaramente identificati, Ogni documento ha una sua lista di distribuzione, L’amministratore gestisce le liste di distribuzione e ne assicura il rispetto.

Milestone: obbligo/opportunità misuratore di avanzamento di progresso. Indica un punto nel tempo (calendario). Importanti traguardi intermedi nello svolgimento del progetto. Ogni milestone di calendario è associata a uno specifico insieme di baseline. Indica importanti traguardi intermedi nello svolgimento del progetto.
Le milestone servono per fissare dei punti di avanzamento significativi rispetto agli obiettivi stabiliti e al tempo a disposizione. Un progettatore assegna milestone che hanno una distanza tale per cui arrivarci significa raggiungere un punto importante: infatti, ogni milestone corrispone a una specifica configurazione del sistema. Ogni milestone ha un proprio nome se associata e una configurazione detta baseline.

Baseline:  è stato di incremento, punto di arrivo tecnico dal quale non scendo, risultato sulla quale baso l'incremento. Campobase punto di arrivo tecnico, vicino alla fine, realizzazione stabile, risultato sulla quale basare il successivo incremento, si può tornare a baseline precedenti. E' il prodotto tangibile, associato alle milestone.
Quello di baseline indica un punto d’arrivo tecnico dal quale non si retrocede; la baseline è fatta di elementi della configurazione e, poiché ogni parte è versionata, possiamo conoscere la differenza tra una baseline e l’altra. Una baseline è qualcosa di stabile — non usa e getta! — e sta in un repository; serve da base per gli avanzamenti futuri e può essere cambiata solo tramite procedure di controllo di cambiamento.
2. La baseline è una versione approvata di un configuration item che è stata formalmente progettata e definita (/sistemata, ”fixed”) in un momento specifico del ciclo di vita del configuration item. [SWEBok 6-7]
3. Una baseline è una collezione delle versioni dei componenti che compongono un sistema. Le baseline sono controllate, il che significa che le versioni dei componenti che compongono il sistema non possono essere cambiate e che è sempre possibile ricreare
una baseline a partire dai componenti che la costituiscono. [Sommerville, pag 684]

Controllo di baseline: L’insieme di CI consolidato a una specifica milestone.
Base verificata, approvata e garantita per la prosecuzione dello sviluppo.
L’esistenza di baseline ben identificate permette Riproducibilità, Tracciabilità, Analisi e confronto.

Le richieste di modifiche hanno origine da Utenti (difetti o mancanze) Sviluppatori (idem) Competizione (valore aggiunto).
Le richieste di modifica vanno sottoposte a un rigoroso processo di analisi, decisione, realizzazione e verifica.
Ogni richiesta/proposta di modifica va inoltrata in modo formale -> Change request.
Di ogni richiesta di modifica bisogna tenere traccia di: Issue tracking(sistema informatico che gestisce e registra delle liste di richieste di assistenza o di problemi) o ticketing e di Stato corrente ed eventuale esito chiusura.
Si appoggia su un repository->DB centralizzato nel quale risiedono - individualmente – tutti i CI di ogni baseline nella loro storia completa.
Permette a ciascuno di lavorare su vecchi e nuovi CI senza rischio di sovrascritture accidentali e di condividere il lavorato nello spazio comune.
Verifica la bontà di ogni modifica di baseline = Build.
Versione = Istanza di prodotto funzionalmente distinta dalle altre.
Variante = Istanza di prodotto funzionalmente identica ad altre ma diversa per caratteristiche non funzionali.
Rilascio (release) = Istanza di prodotto resa disponibile a utenti esterni.
Tutte vanno identificate, pianificate e gestite.

L6

Way of working: crea requisiti, verifico ma non valido la way of working.
Le norme di progetto descrivono come dovrà essere il way of working.
Individuiamo due categorie di norme: regole (sottoposte a verifica) e raccomandazioni (suggerimenti, senza verifica).

-Qualifica = Verifica+Validazione due processi distinti la cui unione da la qualifica.
-Verifica: Accertare che l’esecuzione delle attività di processo non abbia introdotto errori "did i build the system right". Rivolta ai processi ma viene svolta sui loro prodotti per accertare il rispetto di regole, convenzioni e procedure; accerta il rispetto di norme e procedure.
-Validazione: "did i build the right system"Accertare che il prodotto realizzato corrisponda alle attese, rivolto ai prodotti finali; che prodotto finale sia conforme, soddisfi requisiti.
Self fulfilling prophecy, dico prima so che accade, attività preventive di verifica che diano informazione, applicata la modo in cui lavoro.

Requisiti
Condizione (capability) necessaria a un utente per risolvere un problema o raggiungere un obiettivo
Condizione (capability) che deve essere soddisfatta o posseduta da un sistema per adempiere a un obbligo

Analisi
Studio dei bisogni e delle fonti;
Classificazione dei requisiti;
Modellazione concettuale del sistema (visione Use Case): Partizionamento in componenti (ambiti) a scopo di allocazione dei requisiti (con diagrammi dei casi d’uso);
Assegnazione dei requisiti a parti distinte del sistema;
Negoziazione con il committente e con i sotto-fornitori.

Gli attributi di prodotto definiscono le caratteristiche richieste al sistema, Requisiti funzionali, prestazionali, di qualità (di prodotto).
Gli attributi di processo pongono vincoli sui processi impiegati nel progetto, come farlo,requisiti di vincolo (realizzativo, normativo, contrattuale).

I requisiti hanno diversa utilità strategica:
-Obbligatori Irrinunciabili per qualsiasi stakeholder;
-Desiderabili Non strettamente necessari ma a valore aggiunto riconoscibile;
-Opzionali Relativamente utili oppure contrattabili in seguito.
I requisiti non devono essere in conflitto tra loro.

Distinguiamo tra requisiti utente (di alto livello) e requisiti di sistema (più dettagliati).

L'incontro tra bisogno e soluzione viene chiamato tracciamento(l’incontro dei bisogni e dei requisiti,fornisce un dato quantitativo, indica quanti requisiti sono stati soddisfatti,nessuna funzionalità superflua, nessun componente ingiustificato,Tracciare un requisito significa motivarne l’esistenza, spiegando qual è l’origine di tale requisito, badando a garantire la necessità e la sufficienza di ogni requisito), serve al verificatore.

-requisiti funzionali — descrivono i servizi che il sistema deve fornire 
accertiamo il soddisfacimento dei requisiti funzionali attraverso test, dimostrazione formale e revisione.
-requisiti non funzionali — i vincoli sui servizi che il sistema fornisce
-requisiti prestazionali: definiscono quanto bene il sistema sta svolgendo determinate funzioni in certe particolari condizioni,
accertiamo il soddisfacimento dei requisiti prestazionali attraverso misurazione.
-requisiti qualitativi: servono a definire la qualità del prodotto
accertiamo il soddisfacimento dei requisiti qualitativi attraverso verifiche ad hoc
-requisiti di vincolo: sono imposti dal cliente o dall’ambiente operativo in cui funzionerà il sistema
accertiamo il soddisfacimento dei requisiti di vincolo attraverso revisione.

*************************************************************************************************************************

L7 Progettazione Softeare

La progettazione precede la produzione: costruzione a priori perseguendo la correttezza per costruzione invece che inseguendo la correttezza per correzione.
Progettare per:
Dominare la complessità del prodotto («divide-et-impera»);
Organizzare e ripartire le responsabilità di realizzazione;
Produrre in economia (efficienza);
Garantire qualità (efficacia).

(L’analisi risponde alla domanda: qual’è il problema, quale la cosa giusta da fare? Comprensione del dominio Discernimento di obiettivi, vincoli e requisiti, Approccio investigativo.)
La progettazione risponde alla domanda: come farla giusta?
Descrizione di una soluzione soddisfacente per tutti gli stakeholder;
Il codice non esiste ancora;
Prodotti: l’architettura scelta e i suoi modelli logici;
Approccio sintetico.

Enunciazione del problema --(analisi)--> Requisiti del problema --(progettazione)-->  Soluzione del problema

Obiettivi della progettazione
+Soddisfare i requisiti con un sistema di qualità
+Definendo l’architettura logica del prodotto
Impiegando componenti con specifica chiara e coesa
Realizzabili con risorse date e costi fissati
Struttura che facilita eventuali cambiamenti futuri
+ La scelta di una buona architettura facilita il successo
Identificare schemi architetturali utili al caso e componenti riusabili
+Dominare la complessità del sistema
Suddividere il sistema fino a che ciascuna sua componente abbia complessità trattabile
Per facilitare la comprensione e poterne assegnare la codifica a un singolo individuo
+Spingere la progettazione nel dettaglio
Sapendo riconoscere le componenti terminali(Quando il beneficio di ulteriore decomposizione è inferiore al costo di utilizzo)
Più minute le componenti più complessa la loro orchestrazione (Usare classi è più espressivo che usare registri di CPU).

Definizione iso/iec 42010:2011
-La decomposizione del sistema in componenti
-L’ organizzazione di tali componenti (Definizione di ruoli, responsabilità, interazioni cioè chi fa cosa e come)
-Le interfacce necessarie all’interazione tra le componenti tra loro e con l’ambiente (Come le componenti possono collaborare)
-I paradigmi di composizione delle componenti (Regole, criteri, limiti, vincoli, anche a fini di manutenibilità).

An architectural style is a named collection of architectural design
decisions that
• are applicable in a given development context
• constrain architectural design decisions that are specific to a
particular system within that context
• elicit beneficial qualities in each resulting system

Esistono stili architetturali
Aderire a uno «stile» garantisce coerenza e consistenza.
Le «scelte architetturali» determinano l’organizzazione dell’informazione e l’interazione tra le parti.

Qualità di una buona architettura
+Sufficienza: capacità di soddisfare tutti i requisiti.
+Comprensibilità: può essere capita dai portatori di interesse..
+Modularità: è suddivisa in parti chiare e ben distinte
+Robustezza: è capace di sopportare ingressi diversi (giusti sbagliati tanti pochi) dall'utente e dall'ambiente.
+Flessibilità: permette modifiche a costo contenuto al variare dei requisiti.
+Riusabilità: sue parti possono essere utilmente impiegate in altre applicazioni.
+Efficienza: nel tempo nello spazio e nelle comunicazioni.
+Affidabilità: reliability è altamente probabile che svolga bene il suo compito quando utilizzata.
+Disponibilità(availability): necessita di poco o nullo tempo di manutenzione fuori linea(non tutto il sistema deve essere interrotto se qualche sua parte è sotto intervento).
+Sicurezza rispetto a malfunzionamenti(safety): è esente da malfunzionamenti gravi (il sistema dispone di un sucìfficiente grado di ridondanza per restare utilmente operativo anche in presenza di guasti locali).
+Sicurezza rispetto a intrusioni(security): i suoi dati e le sue funzioni non sono vulnerabilli a intrusioni.
+Semplicità: ogni parte contiene solo il necessario e niente di superfluo.

+Incapsulazione(information hiding): l'interno delle componenti non è visibile all'esterno. Le componenti sono “black box”, I suoi clienti ne conoscono solo l’interfaccia. La loro specifica nasconde gli algoritmi e le strutture dati usati al loro interno. Benefici: L’esterno non può fare assunzioni sull’interno; Cresce la manutenibilità; Diminuendo le dipendenze aumentano le opportunità di riuso.

+Coesione: le parti che stsnno assieme hsnno gli stessi obiettivi.
[SOLID]
Proprietà interna di singole componenti, Funzionalità “vicine” devono stare nella stessa componente, La modularità spinge a decomporre il grande in piccolo, La ricerca di coesione aiuta sia a decomporre che a porre un limite inferiore alla decomposizione
La coesione va massimizzata!
Benefici Maggiore manutenibilità e riusabilità Minore interdipendenza fra componenti, Maggiore comprensione dell’architettura del sistema.
Vi sono svariati tipi di coesione buona:
- Funzionale, quando le parti concorrono al medesimo specifico compito
- Sequenziale, quando alcune azioni sono «vicine» ad altre per ordine di esecuzione e dunque conviene tenerle insieme
- Informativa, quando le parti agiscono sulla stessa unità di informazione


+Basso accoppiamento: parti distinte dipendono poco o niente le une dalle altre. 
•Parti diverse possono avere un grado di interdipendenza cattiva tra loro: 
-Facendo assunzioni dall’esterno su come le parti facciano il loro mestiere all’interno (per variabili, locazioni, tipi)
-Imponendo vincoli dall’esterno sull’interno di una parte (per ordine di azioni, uso di certi dati, formati, valori)
-Condividendo frammenti delle stesse risorse (strutture dati)
•Un sistema è un insieme organizzato Dunque ha necessariamente un po’ di accoppiamento (la buona progettazione lo tiene basso)
•Indice di utilità FanIn -> f() -> FanOut  indice di dipendenza (accoppiamento)
•L'accoppiamento è una proprietà esterna di componeti
il grado di utilizzo U reciproco di M componeti 
U=MxM massimo accoppiamnto
U=0 accoppiamneto nullo
•Metriche: fanIn e fanOut strutturale  
SFIN è indice di utilità -> massimizzare 
SFOUT è indice di dipendenza -> minimizzare
Una buona progettazione produce componenti con SFIN elevato


Progettazione architetturale
Top-down: Decomposizione di problemi, Stile funzionale.
Bottom-up: Composizione di soluzioni, Stile object-oriented.
Meet-in-the-middle : Approccio intermedio Il più frequentemente seguito.


Framework
-Insieme integrato di componenti SW prefabbricate, nel mondo pre-OO erano chiamate librerie
Sono bottom-up perché fatti di codice già sviluppato
Sono anche top-down se impongono uno stile architetturale
-Utilissimi come base facilmente riusabile di diverse applicazioni entro un dato dominio
Molti importanti esempi nel mondo J2EE e JS
Spring (http://www.springsource.org/about) per architetture di business con MVC
Struts (http://struts.apache.org/) per Web Apps in stile MVC
Swing per GUI, ecc.

Pattern Architetturali
-Soluzioni fattorizzate per problemi ricorrenti
Metodo tipico dell’ingegneria classica
La soluzione deve riflettere il contesto (La soluzione deve soddisfare il bisogno e non viceversa!)
La soluzione deve essere credibile (dunque provata altrove)
Esempi
 Modello di cooperazione di tipo cliente-servente
 Comunicazione a memoria condivisa o scambio di messaggi
 Comunicazioni sincrone (interrogazione e attesa)
 Comunicazioni asincrone (per eventi)

Design Pattern:
Soluzione progettuale a problema ricorrente
Definisce una funzionalità lasciando gradi di libertà d’uso (Ha corrispondenza precisa nel codice sorgente)
Il corrispondente architetturale degli algoritmi che invece specificano procedimenti di soluzione
Rilevante nel SW a partire dalla pubblicazione di “Design Patterns” della Gang of Four 
Per la progettazione a livello sistema si usano pattern architetturali!

Pattern Architetturali:
-Architettura “three-tier” (a livelli)
 Strato della presentazione (GUI)
 Strato della logica operativa (business logic)
 Strato dell’organizzazione dei dati (database)
-Variante multilivello (pila OSI e TCP/IP)
-Architettura produttore-consumatore
 Collaborazione a pipeline
-Architettura cliente-servente
 Con cliente complesso (“fat client”) Meno carico sul servente ma scarsa portabilità
 Con cliente semplificato (“thin client”) Maggior carico di comunicazione ma buona portabilità
-Architettura “peer-to-peer”
 Interconnessione di scambio senza server intermedio


Progettazione di dettaglio: attività
-Definizione delle unità realizzative (moduli)
 Un carico di lavoro realizzabile dal singolo programmatore;
 Un “sottosistema” definito-> Un componente terminale (non ulteriormente decomponibile) o un loro aggregato;
 Un insieme di entità (tipi, dati, funzionalità) strettamente correlate -> Raccolti insieme in un package (come un insieme di classi) Nei  sorgenti oppure nel codice oggetto (come in Java).
-Specifica delle unità come insieme di moduli
 Definizione delle caratteristiche significative-> Da fissare nella progettazione;
 Dal nulla o tramite specializzazione di componenti esistenti.


Progettazione di dettaglio: obiettivi
-Assegnare unità a componenti
 Per organizzare il lavoro di programmazione;
 Per assicurare congruenza con l’architettura di sistema;
-Produrre la documentazione necessaria.
 Perché la programmazione possa procedere in modo certo e disciplinato;
 Tracciamento per attribuire requisiti alle unità;
 Per definire le configurazioni ammissibili del sistema.
-Definire gli strumenti per le prove di unità
 Casi di prova e componenti ausiliarie per la verifica unitaria e di integrazione.

Documentazione
IEEE 1016:1998 Software Design Document
Introduzione (Come nel documento AR, software requirements specification)
Riferimenti normativi e informativi
Descrizione della decomposizione architetturale (Moduli, processi, dati)
Descrizione delle dipendenze (tra moduli, processi, dati)
Descrizione delle interfacce (tra moduli, processi, dati)
Descrizione della progettazione di dettaglio


SEMAT (Software Engineering Method and Theory) drives a process to refound software engineering based on a solid theory, proven principles and best practices.

Stati di progresso per SEMAT
-Architecture selected
 Selezione di una architettura tecnicamente adatta al problema:
  accordo sui criteri di selezione;
  Selezione delle tecnologie necessarie;
  Decisioni su buy, build, make.
-Demonstrable
 Dimostrazione delle principali caratteristiche dell’architettura: gli stakeholder concordano;
 Decisione sulle principali interfacce e configurazioni di sistema.
-Usable
 Il sistema è utilizzabile e ha le caratteristiche desiderate;
 Il sistema può essere operato dagli utenti;
 Le funzionalità e le prestazioni richieste sono state verificate e validate;
 La quantità di difetti residui è accettabile.
-Ready
 La documentazione per l’utente è pronta;
 Gli stakeholders hanno accettato il prodotto e vogliono che diventi operativo.

Fine L7 
*********************************************************************************************
L10 Qualità del software 

Il concetto di qualità è correlato a quello di valutazione(comparativa o di conformità).
La valutazione della qualità ha più destinatari, chi fa, chi usa, chi valuta.

Qualità: Insieme delle caratteristiche di un'entità che ne determinano la capacità di soddisfare esigenze espresse e implicite
(ISO 8402:1994, glossario dei termini, confluito in ISO 9000:2005)

Sistema qualità: La struttura organizzativa, le responsabilità, le procedure, i procedimenti, e le risorse messe in atto per il perseguimento della qualità. (ISO 8402:1994 → ISO 9000:2005)

Aree di intebento del sistema qualità:
Intrinseca -> conformità ai requisiti, idoneità all'uso
Relativa -> soddisfazione del cliente
Quantitativa -> misura dle livello di qualità per controllo

Ambiti del sistema qualità:
Pianificazione -> definizione di politica e obiettivi
Controllo
Miglioramento continuo

Pianificazione di qualità: Le attività del sistema qualità mirate a fissare gli obiettivi di qualità, i processi e le risorse necessarie per conseguirli (ISO 9000)
Piano di qualità:
Fissa le politiche aziendali per il perseguimento della qualità (visione orizzontale-trasversalmente sull'intera organizzazione)
Determina gli obiettivi di quallità del singolo progetto (visione verticale-specificamente per un prodotto/servizio)
Assume l'uso di opportuno strumenti e modalità di controllo

Controllo di qualità: Le attività del sistema qualità pianificate e attuate al fine che il prodotto soddisfi i requisiti attesi (iso 9000)
Controllo di qualità - Modalità e ambiti di controllo:
comprensione e analisi del dominio
verifica(di attività di  processo)
validazione(di prodotto)
quality assurance (preventiva, non correttiva)

Impatto degli standard sulla qualità:
-Raccolta organica di best practice
 Per evitare la ripetizione di errori passati
-Idonea alla concezione e attuazione di processi di quality assurance
 Chiave del miglioramento continuo
-Elemento di continuità
 I nuovi assunti possono comprendere l’organizzazione aziendale a partire dagli standard di qualità in uso

Il lato negativo dell'impatto degli standard:
-Il personale può percepire gli standard come irrilevanti o bloccanti
-L’attuazione di standard svincolata da controlli di efficacia sfocia in eccessi di burocrazia
-Senza il supporto di strumenti informatici possono richiedere frustranti attività manuali


Modelli della qualità SW:
-Strumenti utili alla valutazione
 Nella visione dell’utente -> Rispetto all’uso;
 Nella visione della produzione -> Rispetto a qualifica, manutenzione, portabilità, riuso;
 Nella visione della direzione -> Rispetto al rapporto costi/benefici.
-Un solo modello per committenti e fornitori
 Per uniformare la percezione e la valutazione della qualità.
-Approccio comune a tutti i modelli
 Definizione delle caratteristiche rilevanti;
 Loro organizzazione in una struttura logica.
-Modello di Boehm
 7 caratteristiche principali Suddivise in 15 sotto-caratteristiche misurabili tramite metriche ad-hoc.
-ISO/IEC 9126:2001
 Software engineering - Product quality - Part 1: Quality model;
 7 caratteristiche principali – 31 sotto-caratteristiche.

L'iceberg della qualità software, la qualità esterna, visibile, è ciò che si osserva tramite esecuzione. E' causata dalla qualità interna. La qualità interna è ciò che deriva da scelte di progettazione, codifica, verifica e che si vede solo tramite revisione critica.

Riferimenti normativi
-Strumento di definizione e valutazione
 Def: catalogazione sistematica delle caratteristiche rilevanti;
 Val: definizione di metriche per la loro valutazione.
-Def: modello della qualità SW (ISO/IEC 9126)
 Visione esterna : relativa all’esecuzione del prodotto (Product requirements);
 Visione interna : relativa al prodotto non in esecuzione (Product-component requirements);
 Visione in uso : relativa alla percezione dell’utente / operatore(Customer requirements).
-Valutazione della qualità SW (ISO/IEC 14598)
 Misurazione quantitativa: «l’uso di una metrica per assegnare un valore (numeo o categoria) su una scala predefinita»;
 Meglio: «il processo attraverso cui, secondo regole definite, simboli o numeri sono assegnati ad attributi di una entità»
 [N.Fenton, Software metrics, a rigorous approach, 1997].
-ISO/IEC 25000:2005 ha inglobato 9126 e 14598
 SQuaRE: Software product Quality Requirements and Evaluation
 Q requirements → Q model → Q management → Q measurement → Q evaluation.

Softaware Metrics:
-Any type of measurement which relates to a software system, process or documentation
 Program: SLOC. Text: Gunning’s fog index. Effort: person-days 
 Fog = (average number of words per sentence) + (number of words of 3 syllables or more) ) * 0.4
-Allow the product and the process to be quantified
-May be used to predict product attributes or to control the software process
-Product metrics can be used for general predictions or to identify anomalous components

Metrics Assumpions:
-A software property or attribute can be measured.
-A relationship exists between what we can measure and what we want to know
 We only know how to measure internal attributes;
 But we are often more interested in external attributes.
-This relationship has been formalised and validated.
-It may be difficult to relate what can be measured to desirable external quality attributes.

Qualità nel ciclo di vita:
-Qualità obiettivo(responsabilità del committente)
 soddisfacimento dei requisiti misura di qualità parzialmente implicita.
-Qualità richiesta(responsabilità del committente e del fornitore)
 sancita contrattualmente misura di qualità esplicita.
-Qualità progettata(responsabilità del fornitore).
-Qualità stimata(responsabilità del fornitore).
-Qualità consegnata(responsabilità del fornitore).

Fine L10

******************************************************************

L11 Qualità di processo

Qualità del processo come esigenza: organizzazione e diffusione interna sistematica; identificazione di prodotti intermedi e di momenti di verifica; riproducibilità dei risultati; quality assurance(non solo sistematica ma sempre più proattiva(preventiva)).
Disposizione la miglioramento.

Definire il processo: per controllarlo e renderlo più facilmente controllabile; per raccontarlo in maniera più convincente.
Controllare il processo per migliorarlo: 
efficacia -> prodotti conformi alle attise;
efficienza -> minori costi a pari qualità di prodotto;
esperienza -> apprendere dall'esperienza(anche dagli altri).
Usare buoni strumenti di valutazione.

Le Norme ISO 9000
Certificaziioni iso 9001 nascono nella metà degli anni 90 per l avalutaione dei fornitori di prodotti o servizi. La famiglia delle norme comprende: 
-iso 9000:2005 Fondamenti e Glossario-> che è radice di modelli di qualità neutri rispetto al dominio di applicazione
-iso 9001:2000 Sistema di Gestione Qualità SGQ - requisiti-> con cui la visione iso 9000 è calata nei sistemi produttivi.
-iso 9000-3:1997  Quality management and quality assurance standards –Part 3: Guidelines for the application of ISO 9001:1994 to the development, supply, installation and maintenance of computer software
nel 2004 rimpiazzato da
-ISO 90003:2004 : Software engineering – Guidelines for the
application of ISO 9001:2000 to computer software
-ISO 9004:2000 : Guida al miglioramento dei risultati

I processi secondo iso9000
Quattro categorie di processi:
Responsabilità della direzione (5.) processi di decisione e controllo
Gestione delle risorse (6.) processi di decisione e controllo
Realizzazione del prodotto (7.) processi di produzione
Misura, analisi e miglioramento (8.) processi di produzione

SGQ come funzione aziendale. Responsabilità SGQ sono garantire qualità trasversalmente a settori e reparti, riferire direttamente alla direzione.

Manuale della qualità
Il documento che definisce il sistema di gestione della qualità di un’organizzazione (ISO 9000).  Visione operativa (orizzontale).
Visione ad alto livello:
Si integra con le procedure aziendali;
Fissa gli obiettivi di qualità e le strategie attuative(esprime la politica azinedale rispetto alla qualità);
Specifica le modalità per la sua evoluzione.

Piano della Qualità (PdQ)
Il documento che definisce gli elementi del SGQ(sistem agestione qualità) e le risorse che devono essere applicate in uno
specifico caso (prodotto, processo, progetto) (ISO 9000)
Taglio operativo:
Concretizza il Manuale della Qualità a livello di progetto, dunque sotto specifici vincoli di tempo e di risorse;
Può avere valenza contrattuale, nel progetto didattico è integrato nel Piano di Qualifica.

Il PdQ in pratica
Accertare disponibilità di: Analisi dei requisiti, Architettura e soluzioni tecniche, Pianificazione delle verifiche, Risultati delle verifiche.
Conformità ai modelli fissati nelle norme.
Accertare tracciabilità tra soluzioni e requisiti.
Assicurare la buona pianificazione delle attività (per uso di risorse).


Strumenti di valutazione

1) SPY-SW Process Assessment and Improvement
valutazione oggettiva dei processi di una organizzazione
per darne un gioudizio di maturità e individuare azioni migliorative

2) CMM capability maturity model 1987 -> CMMI

Il passo successivo: CMMI
CAPABILITY: misura di quanto è adeguato un processo per gli
scopi per cui è stato definito.
Caratteristica di un processo considerato singolarmente.
Determina l’intorno del risultato (di efficienza ed efficacia) raggiungibile utilizzando quel processo.

Un processo a basso livello di capability:
Dipende da chi lo attua;
Viene definito e seguito in modo opportunistico;
Rende difficile prevederne l’esito, l’avanzamento e la qualità;
Porta a compromessi tra funzionalità e qualità.

Un processo ad alto livello di capability è seguito da tutti in modo disciplinato, sistematico e quantificabile.

L’intelligenza dei processi di una organizzazione si chiama «governance».
Efficacia, efficienza, manutenzione, visione.

MATURITY: misura di quanto è governato il sistema dei processi
dell’azienda.
Caratteristica di un insieme di processi.
I processi significativi sono quelli che rispondono alle esigenze di
miglioramento continuo dell’organizzazione. Risulta dall’effetto combinato delle capability dei processi coinvolti.

I cinque livelli di maturità sono:
1'INITIAL process unpredictable, poorly controlled and reactive.
2'MANAGED process characterized for projects and often reactive(Do).
3'Defined process characterized for the organization and is proactive(Plan Do)
4' QUANTITATIVELY MANAGED Process measured and controlled (Plan Check Do)
5'OPTIMIZING focus on process improvement (PDCA)

MODEL: insieme di requisiti via via più stringenti per valutare il
percorso di miglioramento dei processi dell’azienda, utile anche a confrontare tra loro aziende diverse.

INTEGRATION: architettura di integrazione delle diverse discipline (system, HW, SW) e tipologie di attività delle aziende.
Sviluppo di prodotti e servizi (CMMI-DEV).
Gestione ed erogazione di servizi (CMMI-SVC).
Approvvigionamento di prodotti e servizi (CMMI-ACQ).


3) SPICE e iso/iec 15504
Software Process Improvement Capability dEtermination
nato nel 1992 per armonizzare SPY con ISO/IEC 12207 e iso9001
poi confluito in iso/iec tr 15504:1998

15504 livelli e attributi
0-1 performed
1-2 managed
2-3 established
3-4 predictable
4-5 optimizing

evaluation da 0 a 5 e tutti i livelli 15504 possono essere 
not implemented, partially implemnmented, largely implemented, fully implemneted.

Metodologia di valutazione 15504
-Identificazione dei portatori d’interesse
 Destinatari dei risultati
 Responsabili dei processi valutati
 Responsabili delle attività di valutazione
-Scelta tra valutazione e miglioramento
 Risultato a uso esterno o interno
 Valutazione formale o meno (self-assessment)
-Definizione della portata
 Processi inclusi nella valutazione
 Indicatori di valutazione

fine L11
**************************************************************

L12 Verifica e Validazione

Software Verification
Provides objective evidence that the design outputs of a particular
phase of the software development life cycle meet all of the
specified requirements for that phase.
Software verification looks for consistency, completeness, and
correctness of the software and its supporting documentation, as it
is being developed, and provides support for a subsequent
conclusion that software is validated.
La verifica si  occupa di accertare che l'esecuzione delle attività di processi svolti nella fase in esame non abbia introdotto errori nel prodotto.

Software Validation
Confirmation by examination and provision of objective evidence
that the software specifications conform to user needs and intended
uses, and that the particular requirements implemented through
software can be consistently fulfilled.
La validazione si occupa di accertare che il prodotto realizzato sia conforme alle attese.

Forme di Verifica

Analisi Statica
Non richiede esecuzione del prodotto SW in alcuna sua parte(essenziale quando il sistema non è ancora completamente disponibile).
Studia caratteristiche del codice sorgente, talvolta anche del codice oggetto, e della documentazione associata(conformità a regole date, assenza di difetti, presenza di proprietà positive).

Analisi Dinamica
Richiede esecuzione del programma, viene effettuata tramite prove(test). Usata sia nella verifica che nella validazione.

capitolato<-(as)-AR<-(as)-ProgLogica<-(as)-ProgDettaglio 
^AD^
collaudo(as) <-test stema(as) <-test integrazione(as) <-test unità(as)

Analisi dinamica: ambiente di prova
La ripetibilità è requisito essenziale:
-Ambiente (HW, stato iniziale, …)
-Specifica (ingressi richiesti, comportamenti attesi)
-Procedure (esecuzione, analisi dei risultati)
Strumenti:
-Driver componente attiva fittizia per pilotare il test
-Stub componente passiva fittizia per simulare una parte del sistema ma non oggetto di test
-Logger componente non intrusivo di registrazione dei dati di esecuzione per analisi dei risultati

Analisi dinamica: definizioni
Unità:
La più piccola quantità di SW che conviene verificare da sola.
Tipicamente prodotta da un singolo programmatore.
La sua natura specifica dipende dal linguaggio di programmazione in uso,
Va sempre intesa in senso architetturale,
Non linee di codice ma entità di strutturazione (procedura, classe, package).
Il «modulo» è parte dell’unità.
Il «componente» integra più unità.

Test di unità
-Attività di analisi dinamica:
Con il supporto di attività mirate di analisi statica,
Per determinare limiti di iterazioni, flusso di programma, valori di variabili, ecc.
Si svolge con il massimo grado di parallelismo.
-Responsabilità:
Dello stesso programmatore per le unità più semplici,
Di un verificatore indipendente (meglio un automa) altrimenti.
-Obiettivi:
Verificare la correttezza del codice «as implemented».

Test di integrazione
-Per la costruzione e la verifica incrementale del sistema:
Componenti sviluppati in parallelo e verificati
incrementalmente,
In condizioni ottimali l’integrazione è priva di problemi.
-Quali problemi rileva:
Errori residui nella realizzazione dei componenti,
Modifica delle interfacce o cambiamenti nei requisiti,
Riuso di componenti dal comportamento oscuro o inadatto,
Integrazione con altre applicazioni non ben conosciute.

Test di sistema e collaudo
-Validazione:
Test di sistema come attività interna del fornitore (Per accertare la copertura dei requisiti SW)
Collaudo come attività supervisionata dal committente (Per dimonstrazione di conformità del prodotto sulla base di casi di prova)
specificati nel o implicati dal contratto
-Implicazioni contrattuali:
Il collaudo è attività formale
Al collaudo segue il rilascio del prodotto (con eventuale
garanzia) e la fine della commessa (con eventuale
manutenzione)

Test di regressione
L’insieme di test (TU, TI) necessari ad accertare che la
modifica di una parte P di S non causi errori in P o
nelle altri parti di S che hanno relazioni con P
(Ripetizione di test già previsti ed effettuati per ogni parte coinvolta).
Modifiche effettuate per aggiunta, correzione o rimozione, non devono pregiudicare le funzionalità già verificate
(Il rischio aumenta all’aumentare dell’accoppiamento e al diminuire
dell’incapsulazione).

Forme di analisi statica
Non richiedono esecuzione di parti del sistema SW.
Si Applicano a ogni prodotto di processo (non solo SW) (Per tutti i processi attivati nel progetto).
Metodi di lettura (desk check) (Impiegati solo per prodotti semplici).
Metodi formali, basati sulla prova assistita di proprietà (La cui dimostrazione dinamica può essere eccessivamente onerosa).
Metodi formali, verifica di equivalenza o generazione automatica.

Metodi di lettura
-Inspection e Walkthrough
-Metodi pratici
Basati sulla lettura della documentazione sul prodotto
Di efficacia dipendente dall’esperienza dei verificatori nell’organizzare le attività di verifica
e nel documentare le attività svolte e i risultati ottenuti
-Modalità relativamente complementari

Inspection
-Obiettivi
Rivelare la presenza di difetti
Eseguire una lettura mirata [del prodotto in esame]
-Agenti
Verificatori distinti e separati dai programmatori
-Strategia
Focalizzare la ricerca su presupposti
Error guessing

Attività di inspection
Fase 1: pianificazione
Fase 2: definizione della lista di controllo
Fase 3: lettura
Fase 4: correzione dei difetti
In ogni fase->Documentazione come rapporto delle attività svolte

Walkthrough
-Obiettivo
Rivelare la presenza di difetti
Eseguire una lettura critica [del prodotto in esame] a largo spettro e senza l’assunzione di presupposti
-Agenti
Gruppi misti ispettori/sviluppatori ma con ruoli ben distinti
-Strategia (per il codice)
Percorrerlo simulandone possibili esecuzioni

Attività di walkthrough
Fase 1: pianificazione
Fase 2: lettura
Fase 3: discussione
Fase 4: correzione dei difetti
In ogni fase->Documentazione come rapporto delle attività svolte

Inspection contro walkthrough
-Affinità
 Controlli basati su desk check
 Programmatori e verificatori su fronti opposti
 Documentazione formale
-Differenze
 Inspection basato su (errori) presupposti
 Walkthrough richiede maggiore attenzione
 Walkthrough più collaborativo
 Inspection più rapido

Attività di quality assurance
-Serve a raccogliere evidenza oggettiva e di qualità tempestivamente
 A fronte di specifiche metriche e di obiettivi definiti
 Per dare evidenza oggettiva
 Per controllo (interno) e accertamento (esterno)
-ISO/IEC 9126 come riferimento
 "Quali strumenti per quali caratteristiche?"
 La qualità in uso è valutata a posteriori

Funzionalità
-Dimostrabile tramite prove
Analisi statica come attività preliminare.
-Liste di controllo rispetto ai relativi requisiti
Completezza ed economicità (Tutte le funzionalità richieste per tutti e soli i componenti necessari),
Interoperabilità(Accertata la compatibilità tra le soluzioni realizzative adottate),
Sicurezza del prodotto e dei suoi componenti,
Adesione alle norme e alle prescrizioni.
-Valutazione empirica di accuratezza


Affidabilità
-Dimostrabile tramite combinazione di prove e
analisi statica
Analisi statica come attività preliminare
Prove a completamento
-Liste di controllo rispetto ai relativi requisiti
Robustezza
Capacità di ripristino e recupero da errori
Adesione alle norme e alle prescrizioni
-Valutazione empirica di maturità

Usabilità
-Le prove sono imprescindibili
Analisi statica come attività complementare
-Liste di controllo rispetto ai manuali d’uso
Comprensibilità
Apprendibilità
Adesione a norme e prescrizioni
-Questionari sottomessi agli utenti
Facilità e piacevolezza d’uso

Efficienza
-Le prove sono necessarie
Analisi statica come attività complementare
-Liste di controllo rispetto alle norme di
codifica
Quelle che puntano all’efficienza nel tempo e nello spazio
-Margini di miglioramento e confidenza
L’efficienza provata fornisce confidenza nel prodotto
L’analisi statica fornisce indicazioni specifiche sui margini di
miglioramento prestazionale

Manutenibilità
-Analisi statica come strumento ideale
-Liste di controllo
Rispetto a specifiche norme di codifica (Analizzabilità e Modificabilità)
Rispetto alle prove per accertarne (Ripetibilità e Verificabilità)
-Prove di stabilità

Portabilità
-Analisi statica come strumento ideale
-Liste di controllo rispetto a specifiche norme di codifica (Adattabilità)
-Prove come strumento complementare
Facilità d’installazione e di sostituzione
Compatibilità ambientale

************************************

L13 Verifica e validazione: Analisi Statica

-Un SW di buona qualità deve possedere:
Tutte le capacità funzionali specificate nei requisiti, che
determinano cosa il sistema debba fare;
Tutte le caratteristiche non funzionali necessarie per garantire che il sistema lavori sempre come previsto.
-Ciò richiede il possesso verificato di determinate proprietà:
Di costruzione (architettura, codifica, integrazione);
D’uso;
Di funzionamento.

Nessun linguaggio di programmazione garantisce a priori la completa verificabilità di ogni programma scritto in esso perciò occorre cercare buon bilanciamento tra funzionalità (potere espressivo) e integrità (costo di verifica).
Fissato il linguaggio di programmazione, occorre sceglierne i costrutti in funzione del loro impatto (Potere espressivo / costo di verifica).

Programmi verificabili: 

Serve adottare uno standard di codifica e un sottoinsieme di linguaggio consapevoli delle esigenze di verifica
(L’uso di costrutti del linguaggio inadatti può compromettere la
verificabilità del programma).
La verifica solo retrospettiva (a valle dello
sviluppo) è sovente inadeguata. Il costo di rilevazione e correzione di un errore è tanto maggiore quanto più avanzato è lo stadio di sviluppo.

Posticipare la verifica in modalità as-lateas-possible
Approccio retrospettivo -> correctness by correction

Accompagnare la produzione con la verifica
Approccio costruttivo -> correctness by construction

Regolamentare l’uso del linguaggio di programmazione tramite regole da
riflettere nelle Norme di Progetto:
Per assicurare comportamento predicibile
Per usare solidi e collaudati criteri di programmazione
Per ragioni pragmatiche

Comportamento predicibile:

Codice sorgente senza ambiguità
-Effetti laterali (p.es. di funzioni)
Diverse invocazioni della stessa funzione producono risultati diversi.
-Ordine di elaborazione e inizializzazione
L’esito di un programma dipende dall’ordine di elaborazione entro e tra unità. Per esempio, l’attivazione dei thread in Java è fonte di impredicibilità.
-Modalità di passaggio dei parametri
La scelta di una modalità di passaggio (per valore, per riferimento) può influenzare l’esito dell’esecuzione.

Criteri di programmazione:
-Riflettere l’architettura nel codice
Programmazione strutturata per esprimere componenti, moduli, unità come da progettazione, e facilitare il riuso.
-Separare le interfacce dall’implementazione
Fissare bene le interfacce già a partire dall’architettura logica.
-Massimizzare l’incapsulazione (information hiding)
Usare membri privati e metodi pubblici per l’accesso.
-Usare tipi specializzati per specificare dati
La composizione e la specializzazione aumentano il potere
espressivo del sistema di tipi del programma.


Considerazioni pragmatiche:
-L’efficacia dei metodi di analisi è funzione della
qualità di strutturazione del codice
Esempio: un modulo con un solo punto di ingresso (pre-) e un
solo punto di uscita (post-) è più facilmente analizzabile per il
suo effetto sullo stato
-La verifica di un programma relaziona frammenti
di codice con frammenti di specifica
La verificabilità è funzione inversa della dimensione del contesto
(Conviene confinare gli ambiti (scope) e la visibilità);
Una buona architettura facilita la verifica, Esempio: incapsulazione dello stato e controllo di accesso.

Tracciamento
Tracciamento per dimostrare completezza ed economicità della soluzion, cioè il Soddisfacimento di tutti i requisiti, nessuna funzionalità superflua, nessun componente ingiustificato.
Il tracciamento ha luogo su ogni passaggio dello sviluppo (ramo discendente) e su ogni ramo della verifica (ramo ascendente).
Il tracciamento può essere totalmente automatizzato.

capitolato<-(tracciamento)-AR<-(tracciamneto)-ProgLogica<-(tracciamneto)-ProgDettaglio 
^tracciamneto^
collaudo<-test stema <-test integrazione <-test unità

Particolari stili di programmazione facilitano il tracciamento
Assegnare singoli requisiti elementari a singoli moduli del programma richiede una sola procedura di prova e rende più chiara e semplice la corrispondenza tra essi.
Maggiore l’astrazione (potenza espressiva) di un costrutto del linguaggio maggiore è la quantità di codice oggetto eseguito per esso e maggiore l’onere di dimostrazione di corrispondenza
Bassa astrazione: addizione tra interi,
Alta astrazione: attivazione di un thread.

10 tipi di analisi statica

1) Analisi di flusso di controllo
Accertare che il codice esegua nella sequenza specificata.
Accertare ch eil codice si aben strutturato.
Localizzare codice non raggiungibile.
Identificazionne dei segmenti d'esecuzione che possano non terminare: divieto di modifica di variabili di controllo delle iterazioni;
e l’analisi dell’albero delle chiamate (call-tree analysis) mostra se
l’ordine di chiamata corrisponda alla specifica e rileva la
presenza di ricorsione diretta o indiretta.

2) Analisi di flusso dei dati
Accertare che nessun cammino d’esecuzione del programma acceda a variabili prive di valore, usa i risultati dell’analisi di flusso di controllo insieme alle informazioni sulle modalità di accesso alle variabili (lettura, scrittura).
Rilevare possibili anomalie per Esempio: più scritture successive senza letture intermedie.
Attività complicata dalla presenza e dall’uso di dati globali raggiungibili da ogni parte del programma.

3) Analisi di flusso d'informazione
Determinare quali dipendenze tra ingressi e uscite risultino dall'esecuzione di una unità di codice.
Le solo dipendenze consentite sono quelle previste dalla specifica(consente l'identificazione di effetti  laterali inattesi o indesiderati).
Può limitarsi a un singolo modulo oppure estendere a più moduli correlati oppure anche all'intero sistema.

4) Esecuzione simbolica
Verificare proprietà del programma mediante manipolazione algebrica del codice sorgente (combinando tecniche di analisi di flusso di controllo, di flusso di dati e di flusso di informazione).
Si esegue effettuanzdo "sostituzioni inverse" (sostotuendo a ogni LHS di un assegmaneto il suo RHS).
Trasformando così il flusso sequenziale del programma in un insieme di assegmaneti paralleli le cui uscite sono funzione degli ingressi.

5) Verifica formale del codice
Provare la correttezza del codice sorgente rispetto alla specifica algebrica dei requisiti(esplorando tutte le esecuzioni possibili, non fattibile tramite analisi dinamica).
Correttezza parziale->le condizioni di verifica sono espresse ocme teoremi la cui verità implica certe precondizioni in ingresso e certe postcondizioni in uscita, la prova di correttezza vale sotto l'ipotesi di terminazione del programma, la prova di correttezza totale richiede prova di terminazione.

6) Analisi di limite
Verificare che i dati del programma restino entro i limiti del loro tipo e della precisione desiderata quindi:
 Analisi di overflow e underflow
 Analisi di errori di arrotondamento
 Rispetto dei limiti (range checking)
 Analisi di limite di strutture.
Linguaggi evoluti assegnano limiti statici a tipi discreti consentendo verifiche automatiche sulle corrispondenti variabili (Più problematico con tipi enumerati e reali).

7) Analisi d'uso di stack
Lo stack è l’area di memoria che i sottoprogrammi usano per immagazzinare dati locali, temporanei e indirizzi di ritorno generati dal compilatore: ogni flusso di controllo (thread) ha un suo proprio stack; l’ampiezza dello stack cresce con l’annidamento di
chiamate di procedura.
Determinare la massima domanda di stack richiesta da un’esecuzione in relazione con la dimensione dell’area di memoria assegnata al processo.
Verificare che non vi possa essere collisione tra stack e heap per qualche esecuzione.
L’heap invece è l’area di memoria globale, l’ampiezza dell’heap è fissata a configurazione e poi consumata con la creazione dinamica di oggetti.

8) Analisi temporale
Studiare le proprietà temporali richieste ed esibite dalle dipendenze delle uscite dagli ingressi del programma (Sapere di produrre il valore giusto al momento giusto).
Limiti espressivi dei linguaggi e delle tecniche di programmazione complicano questa analisi (Iterazioni prive di limite statico (while), ricorso sistematico a strutture dati dinamiche (new), ecc).

9) Analisi d'interferenza
Mostrare l’assenza di effetti di interferenza tra parti separate (“partizioni”) del sistema (non necessariamente limitate a componenti software).
Veicoli tipici di interferenza sono Memoria dinamica (heap) condivisa, dove parti separate di programma lasciano traccia di dati abbandonati ma non distrutti (memory leak), l'azzeramento preventivo delle pagine di memoria riutilizzate (p.es. NT v5.x), l' I/O e altri dispositivi programmabili con effetti a livello sistema (esempio: watchdog).

10) Analisi di codice oggetto
Assicurareche il codice oggetto da eseguire sia una traduzione corretto del codice sorgente corrispondente e ch enessun errore od omissione siano stati introdotti dal compilatore, viene ancora effettuata manualmente, viene facilitata dalle informazioni di corrispondenza prodotte dal compilatore.


Analizzabilità del sistema:
L’analisi statica costruisce modelli astratti del SW in esame.
Questi modelli rappresentano ogni programma come un grafo diretto e ne studiano i cammini possibili.
Le transizioni tra stati (archi) hanno etichette che descrivono proprietà sintattiche o semantiche dell’istruzione corrispondente.
La presenza di flussi di eccezione e di risoluzione dinamica di chiamata (dispatching) complica notevolmente la struttura del grafo.
Ciascun flusso di controllo (thread) viene rappresentato e analizzato separatamente assumendo non-interferenza!

**************************************

L14 Verifica e validazione: Analisi Dinamica

Analisi dinamica = test (prova), attività che comporta esecuzione dell’oggetto di verifica.
Verifica dinamica del comportamento del programma su un insieme finito di casi, selezionati nel dominio (in generale, infinito) di tutte le esecuzioni possibili. Ciascun caso di prova specifica i valori di ingresso e lo stato iniziale del sistema.
Ciascun caso di prova deve produrre un esito decidibile (oracolo) verificato rispetto a un comportamento atteso.

E' Parte essenziale del processo di verifica. Produce una misura della qualità del sistema, aumenta il valore di qualità del sistema identificandone e rimuovendone difetti.
Il suo inizio non deve essere differito al termine delle attività di codifica.  Le sue esigenze devono essere tenute in conto nella progettazione del sistema.

Oggetto delle prove sono Unità, aggregati, sistema completo.

Fault(Guasto/difetto)->Rrror(errore)->failure(malfunzionalmento)

A failure occurs when the behavior of a system deviates from what is specified for it.  Failures result from "problems" internal to the system which eventually manifest in the system's external behavior.

These "problems" are called Errors and their mechanical or algorithmic or conceptual cause are termed faults, Errors are states of the system, Faults are what causes the error to exist.
Systems are hierarchical compositions of components which are themselves systems.

-Obiettivo delle prove
Accettazione, qualifica, conformità, regressione
Installazione nell’ambiente di prova, controllo prestazioni
-Vincoli di progetto
Processi, prodotti, risorse, competenze
Stima e controllo dei costi, criteri di terminazione
-Attività di prova
Pianificazione, specifica e sviluppo dei casi di prova
Esecuzione, valutazione, trattamento dei problemi

La strategia di prova richiede di bilanciare la quantità minima di casi di prova sufficienti a fornire certezza adeguate sulla qualità del prodotto (Fattore governato da criteri tecnici).
La quantità massima di sforzo, tempo e risorse disponibile per la verifica è un fattore governato da criteri gestionali.
Legge del rendimento decrescente -> Diminishing returns

Oggetto della prova:
Il sistema nel suo complesso (Test Sistema). Parti di esso, in relazione funzionale, d’uso, di comportamento, di struttura (Test Integrazione). Singole unità (Test Unità).
Obiettivo della prova:
Specificato per ogni caso di prova .In termini precisi e quantitativi
Varia al variare dell’oggetto della prova. Il PdQ risponde alla domanda "quali e quante prove".

La “provabilità” del SW va assicurata a monte dello sviluppo, non a valle della codifica. Progettazione architetturale e di dettaglio raffinate per assicurare provabilità. La complessità è nemica della provabilità.

Una singola prova non basta, i risultati valgono solo per quella esecuzione e non possono essere generalizzati, la prova deve essere ripetibile.
(Rileva malfunzionamenti indicando la presenza di guasti, in generale non può provarne l’assenza).
Le prove sono costose, richiedono molte risorse (tempo, persone, infrastrutture), necessitano di un processo definito, richiedono attività di ricerca, analisi, correzione.

Attività di prova 
specifica->codifica->compilazione->esecuzione->analisi.

Elementi di una prova
Caso di prova (test case) è una Tripla <ingresso, uscita, ambiente>
(L’ambiente include l’oggetto della prova)
Una Batteria di prove (test suite) è un Insieme (sequenza) di casi di prova.
Una Procedura di prova è Il procedimento (automatico o manuale) per eseguire, registrare, analizzare e valutare i risultati di prove.
Prova = <Procedura, Batteria di prove>

[p17 oracolo]

Unità software composta da uno o più moduli, Modulo = componente elementare di progetto di dettaglio (quindi non necessita di test di unità).
Unità e moduli sono determinati in progettazione di dettaglio e quindi anche il piano di TU. La TU completa quando ha verificato tutte le unità.
(~2/3 dei difetti identificati tramite analisi
dinamica vengono rilevati in TU, 50% di essi viene identificato da prove strutturali(white-box)).

Per ogni test di unità si definiscono: Oggetto, strategia, risorse necessarie, piano di esecuzione.
Si ha Statement Coverage al 100% quando i test effettuati sull’unità sono sufficienti a eseguire – complessivamente – almeno una volta tutte le linee di comando di ciascuno dei moduli dell’unità.
Si ha Branch Coverage al 100% quando ciascun ramo del flusso di controllo viene attraversato – complessivamente – almeno una volta.
Lo statement coverage è meno potente del branch coverage.

Copertura 
Definizione (DO-178B)
Condizione=Espressione booleana semplice non contenente al suo interno ulteriori condizioni combinate da operatori booleani.
Decisione=Espressione composta contenente condizioni combinate da operatori booleani.
Al crescere del numero di condizioni all’interno di una decisione il numero di test necessario a massimizzare il condition coverage diventa proibitivo.
DO-178B richiede allora di massimizzare il modified decision condition coverage, MCDC implica branch coverage.
Requisiti DO-178B (software di avionica) richiede che tutte le decisioni siano soggette a test e tutti i loro possibili esiti siano effettivamente prodotti, che ciascuna condizione all’interno di una decisione assuma entrambi gli esiti (vero/falso) almeno una volta.
Occorre allora verificare se e come ogni singola condizione possa da sola determinare tutti gli esiti possibili della decisione e non basta più provare l’intera decisione come vera
o falsa!

Test di Unità: Test funzionale (black-box)
Da solo non può accertare correttezza e completezza della
logica interna dell’unità (Va necessariamente integrato con test strutturale).
Fa riferimento alla specifica dell’unità e utilizza dati di ingresso capaci di provocare l’esito atteso.
Ciascun insieme di dati di ingresso che producono un dato
comportamento funzionale costituisce un caso di prova.
Classi di equivalenza invece che infiniti valori di ingresso (Valori nella medesima classe producono lo stesso comportamento).

Test di Unità: Test strutturale (white-box)
Verifica la logica interna del codice dell’unità cercando massima copertura.
Ciascuna prova deve essere progettato per attivare ogni cammino di esecuzione all’interno del modulo.
Ciascun insieme di dati di ingresso che attivano un percorso costituiscono un caso di prova.
L’uso di debugger può agevolarne l’esecuzione ma non esonera dalla progettazione dei casi di prova.

Strategie di integrazione
Assemblare parti in modo incrementale aggiungendo solo a insiemi ben verificati, i difetti rilevati in un test di integrazione sono più probabilmente da attribuirsi alla parte ultima aggiunta.
Assemblare produttori prima dei consumatori, la verifica dei primi fornisce ai secondi flusso di controllo (chiamate) e flusso dei dati corretti.
Assemblare in modo che ogni passo di integrazione sia reversibile, consente di retrocedere verso uno stato noto e sicuro.

Integrazione incrementale
Bottom-up
Si sviluppano e si integrano prima le parti con minore dipendenza funzionale e maggiore utilità, poi si risale l’albero delle dipendenze, questa strategia riduce il numero di stub necessari al test ma porta più tardi alla disponibilità di funzionalità di alto livello.
Top-down
Si sviluppano prima le parti più esterne, quelle poste sulle foglie
dell’albero delle dipendenze e poi si scende, questa strategia comporta l’uso di molti stub ma integra a partire dalla funzionalità di più alto livello.

Test di Integrazione
Si applica alle componenti specificate nella
progettazione architetturale, la loro integrazione costituisce il sistema completo.
La Logica di integrazione funzionale seleziona le funzionalità da integrare, identifica le componenti che svolgono quelle funzionalità,ordina le componenti per numero di dipendenze crescente
(Dipendenze nel flusso di controllo (chiamata) e nel flusso di dati) ed esegue l’integrazione in quell’ordine.
I problemi rilevati durante Test di Integrazione manifestano difetti di progettazione o insufficiente qualità nei test di unità.
Test di Integrazione ha tanti test quanto ne servono per accertare che tutti i dati scambiati attraverso ciascun interfaccia siano conformi alla loro specifica e per accertare che tutti i flussi di controllo previsti in specifica siano stati effettivamente realizzati e provati.

Test di sistema
Verifica il comportamento dinamico del sistema completo rispetto ai requisiti SW.
Ha inizio con il completamento del test di integrazione.
È inerentemente funzionale (black-box) (non dovrebbe richiedere conoscenza della logica interna del software).


Altri tipi di test

Test di regressione
Ripetizione selettiva di TIntegrazione (e poi di TSistema) integrando solo parti che abbiano precedentemente superato TUnità-> nel repository di progetto devono stare solo unità SW di questo tipo.
Servono Per accertare che modifiche intervenute per correzione o
estensione di parti non comportino errori nel sistema (Può essere molto oneroso).
I contenuti del test di regressione vanno decisi nel momento in cui si approvano modifiche al SW.

Test di accettazione (collaudo) Accertano il soddisfacimento dei requisiti utente.

Fattore di copertura
-Quanto la prova esercita il prodotto:
Copertura funzionale (Rispetto alla percentuale di funzionalità esercitate come viste dall’esterno)
Copertura strutturale (branch, condition) (Rispetto alla percentuale di logica interna del codice esercitata).
-Una misura della bontà di una prova
Copertura del 100% non prova assenza di difetti, il 100% di copertura può essere irraggiungibile (per Costi eccessivi, codice sorgente non disponibile, codice irraggiungile non eliminabile, copertura esaustiva dei cicli).

Maturità di prodotto
-Valutare il grado di evoluzione del prodotto
Quanto il prodotto migliora in seguito alle prove
Quanto diminuisce la densità dei difetti
Quanto può costare la scoperta del prossimo difetto
-Le tecniche correnti sono spesso empiriche
Sotto l’influenza del modello code-and-fix
-Definire un modello ideale
Modello base: il numero di difetti del SW è una costante iniziale
Modello logaritmico: le modifiche introducono difetti

***********************************************************

